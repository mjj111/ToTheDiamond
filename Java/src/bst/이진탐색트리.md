
---
[이중 우선순위 큐](https://www.acmicpc.net/problem/7662)
--
Q.이중 우선순위 큐는 기존의 전형적인 큐와 차이점으로 삭제할 떄 연산 명령에 따라,<br>
우선순위가 낮은 혹은 높은 데이터를 삭제한다.<br>
이 경우에 정수만 저장하는 이중 우선순위 큐가 있다고할 때, <br>
모든 연산 이후에 Q에 저장된 값중 최댓값과 최솟값을 출력하라

A. PriorityQueue를 두면 가장 큰 값에 대해서 빠른 연산이 가능하다.<br>
그러나 기준으로 큰것으로 두면 가장 작은 값에 대해서 접근이 어렵다.<br>
그렇기 때문에 정렬된 상태를 유지하고 가장 큰 값과 가장 작은 값을 접근할 수 있는 이중탐색트리를 사용하는 것이다.<br>
이중탐색트리는 큰값은 오른쪽 작은 값은 왼쪽으로 두는 방법으로 빠르게 접근할 수 있다.<br>
더불어 자바에서는 TreeMap 통해서 정렬된 값들에 대해서 빠르게 접근할 수 있으며 내부적으로 이중탐색트리를 레드블랙트리 기반으로 구현하여 <br>
빠른 추가와 삭제가 가능하며 최대값과 최소값에도 빠르게 접근이 가능하다.

    TreeMap<Integer, Integer> map = new TreeMap<>();
    if(op.equals("I")) {
      int num = Integer.parseInt(st.nextToken());
      map.put(num, map.getOrDefault(num, 0)+1);
    }
    ...
    if(type == 1) num = map.lastKey();
    else num = map.firstKey();
    ...
    if(map.put(num, map.get(num)-1)==1)  map.remove(num);


---
[보석 도둑](https://www.acmicpc.net/problem/1202)
--
Q. 상덕이가 보석점을 털려고할 때, N개의 보석과 무게 M, 가격 V가 주어진다.<br>
그리고 상덕이가 가진 가방은 K개가 있고 각 C 만큼 무게용량이 있다.<br>
상덕이가 최고가격으로 보석을 훔치는 경우 가격을 출력하라.

A. 이 문제에서 가방에 담는 최고의 방법은 현재 가방의 용량안에서 넣을 수 있는 최대 가치를 넣는 것이다.<br> 
여기서 중요한 점은 가방이 보석보다 클 수도 적을 수도 있다. <br>
그렇기 떄문에 가방을 기준으로 보석을 정해야한다.<br>
또한 가격이 가장 비싼 보석부터 꺼내기 위해 가방에 넣을 수 있는 주얼리를 값어치 기준으로 최대 힙 사용해 관리한다.<br>
상덕이가 가진 가방의 용량을 기준으로 오름차순으로 둔다.<br>
그리고 보석에 대해서 무게 오름차순으로 둔다.<br>
이후 해당 가방이 넣을 수 있는 보석들 중 가장 비싼 보석을 가방에 넣도록 한다. (다음 가방은 이전 가방에 용량이 충분한 작은 보석이기 때문에 충분히 꺼낼 수 있다.)

    PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder()); // 최대 힙
    long total = 0;
    int idx = 0;

    for (int bag : bags) {
      while (idx < N && jewels[idx][0] <= bag) {
        pq.offer(jewels[idx][1]);
        idx++;
      }

      if (!pq.isEmpty()) total += pq.poll();
    }

---
[]()
--
Q.

A.