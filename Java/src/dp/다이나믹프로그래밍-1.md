[1,2,3 더하기](https://www.acmicpc.net/problem/9095)
--
Q. 정수를 1,2,3의 합으로 나타내는 방법의 수를 작성하시오. 
1 + 1 + 1 <br>
1 + 2 <br>
3 <br> 
..

A. 이전에 만든 수에서 1 2 3을 더해서 현재 숫자를 만들어 낸다.<br>
즉 i 숫자에서 n(n= 1,2,3)을 뺸 i-n 숫자의 합은 (1,2,3)의 합으로 i숫자를 만들기 위한 방법의 수가 된다. <br>
    
    // dp[i] i를 1,2,3 으로 더해서 만드는 경우의 수  
    for(int i = 4; i <= MAX; i++) {
        for(int n = 1; n<= 3; n++) {
            dp[i] += dp[i-n];
        }
    }
---
[계단 오르기]()
--
Q. 도착 지점으로 계단을 오르는데, 각 지점에 도달할 때마다 점수를 얻는다.<br>
계단을 오르는 방법은 하나 혹은 두 개를 오르는 것인데, 두 개를 연속으로 넘어다닐 수는 없다.<br>
도착했을 때 최고 점수를 출력하시오.

A. 이전을 밟았느냐 밟지 않았느냐에 따라, 2개 넘기가 가능하게된다.<br>
이 경우, 이전의 선택에 따라 최고 점수를 갱신하는 방법으로 도착지점까지 갱신한다. 

    dp[0][j] = 이전 안밟고, j까지 올라는 최대 점수  
    dp[1][j] = 이전 밟고, j까지 올라는 최대 점수  

    for(int x = 3; x<= n; x++) {
      //이전 안밟고, x까지 오기
      // 밟고* 안밟고 전전꺼 + 현재 중에 최대
      dp[NOT][x]  = Math.max(dp[STEPED][x-2], dp[NOT][x-2]) + nums[x];

      //이전 밟고 x까지 오기
      //안밟은 전꺼 + 현재
      dp[STEPED][x] = dp[NOT][x-1] + nums[x];
    }
---
[RGB 거리](https://www.acmicpc.net/problem/1149)
--
Q. N개의 집이 일렬로 있다. 이들은 서로 인접한 집과는 같은 색을 칠해서는 안된다.<br>
이 경우 모든 집을 칠하는 비용의 최솟값을 구하라.

A. 이전 집에 색에 따라 현재 집의 색칠 가능한 경우의 수가 정해진다.<br>
이에 따라 i번째 집을 3가지 색중에 i-1집과는 다르게 해야한다면<br>
2차원 배열로 dp를 사용하여 점화식 dp[i][1] = min(dp[i-1][0], dp[i-1][2]) + value[1]을 사용한다. <br>
즉, i번째 집을 color로 색칠 헀을 때 비용의 최솟값은, 이전집의 다른 색 칠했을 떄 최솟값 + 현재 색칠비용이다.<br>

    int dif1 = color + 1 >= 3 ? 0 : color + 1;
    int dif2 = (color - 1) < 0 ? 2 : color -1;

    dp[now][color] = Math.min(dp[now-1][dif1], dp[now-1][dif2]) + rgb[now][color];
---
[2xn 타일링](https://www.acmicpc.net/problem/11726)
--
Q. 2xn 크기의 직사각형을 1x2, 2x1 타일로 채우는방법의 수를 구하시오.

A. 해당 문제는 너비 n-1 과 n-2 까지 타일을 채웠을 때,<br>
현재 가능한 경우의 수를 누적해서 합하는 것으로 경우의 수를 구할 수 있다. <br>

    for(int i = 3; i <= N; i++) {
      dp[i] = dp[i -1] + dp[i - 2];
    }    

---
[구간합 구하기 4](https://www.acmicpc.net/problem/11659)
--
Q. 수 N개가 주어졌을 떄, i부터 j번째 수 까지의 합을 구하라.

A. prefixSum 을 만들어서 빠르게 i부터 j까지의 합을 구할 수 있도록한다.<br>

    prefixSum[i] = prefixSum[i-1] + nums[i];
    ...
    System.out.println(prefixSum[end] - prefixSum[start-1]);
---
[정수 삼각형]()
--
Q. 다음과 같은 정수 삼각형이 있다고 하자. <br>

            7
          3   8
        8   1   0
      2   7   4   4
    4   5   2   6   5

맨 위층부터 시작해서 아래로 갈 수 있는 인접 수로 하나 선택하여, <br>
맨 마지막 층까지 도달할 때 얻을 수 있는 가장 큰 값을 반환하라. <br>

A. 해당 문제는 이전 선택지에 대하여 보인의 왼쪽 혹은 오른쪽을 택했을 떄 최대값을 갱신하면된다.<br>
즉 dp[i][j] = i층에 j 번째에 도달하고자할 때 가장 큰 점수 획득량은<br>
이전 왼쪽과 오른쪽 dp[i-1][j] dp[i][j-1] 중 최소 값 + 현재 위치 점수가 된다 .<br>
주의할 점은 현재 층의 처음과 끝층은 바로 이전에 대한 왼쪽 혹은 오른쪽 값만 사용할 수 있다는 것이다.<br>
        
    if(j == 0) dp[i][j] = nums[i][j] + dp[i-1][j];
    else if(j == i) dp[i][j] = nums[i][j] + dp[i-1][j-1];
    else dp[i][j] = Math.max(dp[i-1][j], dp[i-1][j-1]) + nums[i][j];
---
[2xN 타일링 2](https://www.acmicpc.net/problem/11727)
--
Q.2×n 직사각형을 1×2, 2×1과 2×2 타일로 채우는 방법의 수를 구하라.

A. 기존 방식과는 살짝 다르다.<br>
왜냐하면, 2x2가 생기면서 너비를 2로 할 수 있는 경우를 양옆으로 전환할(뒤짚을) 수 있기 떄문이다. <br>
그렇기 때문에 너비가 2 이상인 경우에 대해서는 기존 경우의 수를 * 2를 해주는 방법으로 합해줘야한다.<br>
점화식은 아래와 같다.<br>
    
    dp[i] = dp[i - 1] + (2 * dp[i - 2]);

---
[연속합](https://www.acmicpc.net/problem/1912)
--
Q. N개의 정수로 이루어진 임의의 수열에서 연속된 수를 택하여 구할 수 있는 합중, 가장 큰 합을 반환하라.<br>

A. 수를 sum으로 합하는데, 만약 현재 수를 더했을 떄 양수라면 최대값을 갱신한다. <br>
만약 음수가 된다면 다시 sum을 0으로 만들고 합한다. 

    if(sum + now >= 0) {
        sum += now;
        answer = Math.max(answer, sum);
        continue;
    }
    sum = 0;
    answer = Math.max(now, answer);
---
[가장 큰 증가하는 부분 수열](https://www.acmicpc.net/problem/11055)
--
Q. 수열 A가 주어졌을 때, 그 수열의 증가하는 부분 수열 중에서 합이 가장 큰 것을 구하라

A. 현재 숫자의 이전 값들 중 자기보다 작은 숫자의 가장 큰 누적합을 이어 받아 더하는 방식을 사용한다.<br>
점화식은 아래와 같다.<br>

    // 본인 이전에 자기보다 작은 값을 만났다면
    // 해당 작은 값의 누적과 본인을 더해 갱신
    for (int i = 0; i < n; i++) {
      for (int j = 0; j < i; j++) {
        if (nums[j] < nums[i]) {
          dp[i] = Math.max(dp[i], dp[j] + nums[i]);
        }
      }
    }
---
[가장 긴 증가하는 부분 수열](https://www.acmicpc.net/problem/11053)
--
Q.수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하라

A. 현재 숫자의 이전 숫자들 중 현재 보다 작은 숫자의 길이에서 가장 큰 길이를 이어받아 더하는 방식을 사용한다.<br>
점화식은 아래와같다.<br>

    for (int i = 0; i < n; i++) {
      dp[i] = 1; //본인의 길이 1 
      for (int j = 0; j < i; j++) {
        if (nums[i] > nums[j]) {
          dp[i] = Math.max(dp[i], dp[j] + 1);
        }
      }
      maxLength = Math.max(maxLength, dp[i]);
    }
---
[파도반 수열](https://www.acmicpc.net/problem/9461)
--
Q.

A.

---
[퇴사2](https://www.acmicpc.net/problem/15486)
--
Q.

A.

---
[쉬운 계단 수](https://www.acmicpc.net/problem/10844)
--
Q.

A.

---
[자두나무](https://www.acmicpc.net/problem/2240)
--
Q.

A.

---
[가장 긴 증가하는 부분 수열 4](https://www.acmicpc.net/problem/14002)
--
Q.

A.

---
[1, 2, 3 더하기 3 ](https://www.acmicpc.net/problem/15988)
--
Q.

A.

---
[극장 좌석](https://www.acmicpc.net/problem/2302)
--
Q.

A.

---
[카드 구매하기](https://www.acmicpc.net/problem/11052)
--
Q.

A.

---
[스티커](https://www.acmicpc.net/problem/9465)
--
Q.

A.

---
[오르막 수](https://www.acmicpc.net/problem/11057)
--
Q.

A.

---
[동전 1](https://www.acmicpc.net/problem/2293)
--
Q.

A.

---
[01타일](https://www.acmicpc.net/problem/1904)
--
Q.

A.
