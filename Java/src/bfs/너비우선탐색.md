[그림](https://www.acmicpc.net/problem/1926)
--
Q. 도화지에 1로된 그림을 그린다. 상하좌우로 직접 연결되지 않은 그림은 같은 그림이 아니다.<br>
그림 개수 및 그림 중 가장 큰 그림의 넓이 출력

A. 격자에서 1을 만났을 떄 visited 되지 않은 경우 BFS를 실행시키며, 그림 개수를 상승시킨다.<br>
또한 BFS 결과값은 1의 개수를 샌 결과를 반환하며, Math.max()를 통해 최대값을 갱신한다.<br>
결과적으로 개수와 가장큰 넓이를 출력한다.

[미로탐색](https://www.acmicpc.net/problem/2178)
--
Q. 1은 이동할 수 있는칸 0은 이동할 수 없는 칸이라고 했을 떄<br>
(1,1) 에서 출발해서 (N,M)으로 도착할 수 있는 최소한의 칸 수 출력.(상하좌우로만 이동가능)

A. BFS로 1,1부터 시작해서 누적으로 값을 증가시키는 방법을 사용한다<br>
여기서, 현재갖고있는 depth의 값이 다음 이동 칸의 값보다 작다면 이동하지 않는 것으로 한다.

[토마토](https://www.acmicpc.net/problem/7576)
--
Q.2차원 격자에서 익은 토마토는 인접한(네방향) 토마톨를 익도록 한다.<br>
며칠이 되면 모두 다 익게되는지 그 최소 일수를 출력하라. 다 익지 못한다면 -1출력
0은 안익은 토마토, 1은 익은 토마토, -1은 토마토가 없는 칸

A. 모든 토마토의 개수를 센다. <br>
1의 모든 위치를 queue에 넣도록한다<br>
BFS를 돌리는데, depth를 갖고 돌리도록 한다. 본인보다 더 작은 dpeth가 기록되어있으면 접근하지 않는다.<br>
방문시 count를 상승시킨다.<br>
depth중 가장 큰 값을 갱신한다<br>
탐색이 끝났을 떄 count가 모든 토마토의 개수와 다르다면 (적다면) -1을 출력한다. 
그렇지 않다면 격자에서 가장 컸던 dpeth를 출력한다. 

[불!](https://www.acmicpc.net/problem/4179)
--
Q. 미로에 불이나서 불에 타기전에 탈출할 수 있는지의 여부, 얼마나 빨리 탈출 할 수 있는지가 궁금하다.<br>
지훈이와 불은 네방향(상하좌우)으로 움직인다고 할 때, <br>
탈출 할 수 있는경우 가장 빠른 탈출 시간을 출력한다.
그렇지 않다면 IMPOSSIBLE을 출력한다. 

A. 먼저 불에 대해 queue에 넣도록한다. <br>
불은 depth를 가중시키는 방향으로 지도에 BFS 확산하도록한다. (벽이나 불이난 공간은 다시 가지 않는다.)<br>
이 경우 지도에서 불이 몇초에 나는지를 확인할 수 있다.<br>
지훈이는 새로운 격자에 본인의 움직임(depth)을 BFS로 기록한다.<br>
만약 지훈이가 가고자하는 길이 이전에 갔던길이나 벽 혹은 불이 이미 번진 곳은 가지 않도록 한다<br>
지훈이가 드디어 격자 밖의 값에 갈 수 있게된다면 해당 값을 answer로 갱신하고 탐색을 멈춘다. <br>
만약 answer 이 갱신되지 않았다면 IMPOSSIBLE을, 갱신되었다면 answer을 출력한다. 

[스타트링크](https://www.acmicpc.net/problem/5014)
--
Q.F층의 고층건물에서 S층부터 G층으로 도달하기위해 2개의 버튼으로 갈 수 있는지를 출력하시오.<br>
Up 버튼과 Down 버튼은 각자 위, 아래로 가는 버튼이다.<br>
만약 해당 G층에 갈 수 없다면 "use the stairs"를 출력한다.

A. U과 D를 BFS 방식으로 접근한다.<br>
각 층에 대해서 visited로 기록하고 만약 이전에 갔다면 접근하지 않도록한다. <br>
BFS 후 G층의 visited가 변경되어 있지않다면 계단을 쓰라고 출력하고,<br>
변경되어 있다면 그 값을 출력한다. <br>

[상범 빌딩](https://www.acmicpc.net/problem/6593)
--
Q. 정육면체로 이뤄진 빌딩에서 각 층의 단면으로 빌딩 정보가 주어진다.<br>
인접(6)칸에 이동할 수 있을 떄 이동 시간은 1분으로 측정한다.<br>
출구로 탈출 할 수 있는지, 탈출 할 수 있다면 얼마나 걸리는지 출력하라<br>

A. 2차원에서 동작시키던 depth기반 BFS를 3차원으로 변경한다.<br>
int[] dx = {1, -1, 0, 0, 0, 0};  // x축 (좌, 우)<br>
int[] dy = {0, 0, 1, -1, 0, 0};  // y축 (앞, 뒤)<br>
int[] dz = {0, 0, 0, 0, 1, -1};  // z축 (위, 아래)

[벽 부수고 이동하기](https://www.acmicpc.net/problem/2206)
--
Q. 0은 길, 1은 이동할 수 없는 벽이라고하자. <br>
(1,1)에서 (N,M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려한다.<br>
단, 한 개의 벽 정도는 부수고 이동할 수 있다<br>
이 경우 최단 경로를 갈 경우 거리를 구해내시오<br>

A. 1에 대해서 이동하는 BFS에서 조금 바꾼다.<br>
visited를 2차원으로 두는 것이 아닌, 3차원으로 두고<br>
queue  에 들어가는 값을 nx,ny, depth에서 isUsed를 통해 벽의 부순 여부를 추가한다.<br>
이렇게 계산했을 떄, (N,M)에 도착했을 경우 해당 값을 출력한다<br>

[텀 프로젝트](https://www.acmicpc.net/problem/9466)
--
Q. N명의 인원들은 각자 함께하고싶은 친구들이있다. 이들은 팀이 될 수도, 혹은 본인을 가르켜 솔로팀이 될 수도 있다.<br>
각자가 함께하고싶은 친구 번호를 알려줄 때, 이 경우 구성되는 팀의 개수를 출력하라.<br>

A.ArrayList<Integer>를 통해서 방향 그래프를 만든다.<br>
1부터 N까지 각 친구를 접근헀을떄 visited 가 되지 않은 친구를 만나면 카운팅하고 BFS를 돌린다.<br>
카운트를 출력한다.

[빙산](https://www.acmicpc.net/problem/2573)
--
Q. 숫자로 이뤄진 빙산이 있다고한다. 해당 빙산은 상하좌우로 했을 떄 인접한 바다의 수만큼, 녹는다.<br>
이 경우에, 하나의 빙산이 두 개 이상을 나눠지는 시각을 출력하라.

A. 처음에 0이 아닌 값들에 대해서 [x,y]로 큐에 넣도록 한다.<br>
임시 격자를 만든다<br>
큐의 크기 만큼 반복한다.<br>
현재 위치의 빙산의 상하좌우를 검색하여 개수를 샌뒤에 현재의 크기 만큼 빼서, 임시격자에 갱신한다.<br>
만약 0이 되면 지우도록 하고 아니라면 다시 큐에 넣는다.<br>
현재 큐에 있는 값을 기반으로 BFS를 돌려서 2개로 분리되었는지를 확인한다.<br>
확인되었다면 현재 시간을 출력<br>
아직 하나라면 다시 큐의 크기 만큼 반복해서 녹인다<br> 

[다리 만들기](https://www.acmicpc.net/problem/2146)
--
